{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["// A simple TTL cache with max capacity option, ms resolution,\n// autopurge, and reasonably optimized performance\n// Relies on the fact that integer Object keys are kept sorted,\n// and managed very efficiently by V8.\n\n/* c8 ignore start */\nconst perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n/* c8 ignore stop */\n\nconst now = () => perf.now()\nconst isPosInt = (n: any): n is number =>\n  !!n && n === Math.floor(n) && n > 0 && isFinite(n)\nconst isPosIntOrInf = (n: any): n is number =>\n  n === Infinity || isPosInt(n)\n\nexport type DisposeReason = 'set' | 'delete' | 'stale' | 'evict'\n\nexport type DisposeFunction<K, V> = (\n  val: V,\n  key: K,\n  reason: DisposeReason,\n) => unknown\n\nexport type TimeInMilliseconds = number\n\nexport type TTLCacheOptions<K, V> = {\n  /** the maximum number of items to store in the cache */\n  max?: number\n  /** time in ms to store items, must be positive number */\n  ttl?: TimeInMilliseconds\n  /** Update the remaining TTL when getting items */\n  updateAgeOnGet?: boolean\n  /**\n   * Check the remaining age when getting items. Note that if this is not\n   * set, then it's possible to get expired items that have not yet been\n   * preemptively purged.\n   */\n  checkAgeOnGet?: boolean\n  /** Update the remaining TTL when checking for an item's presence */\n  updateAgeOnHas?: boolean\n  /**\n   * Check the remaining age when checking for an items presence. Note that if\n   * this is not set, then expired items will return `true` if they have not yet\n   * been preemptively purged.\n   */\n  checkAgeOnHas?: boolean\n  /** do not update the TTL when setting a new value for an existing key */\n  noUpdateTTL?: boolean\n  /** A function to call when an item is removed from the cache */\n  dispose?: DisposeFunction<K, V>\n  /** Do not call `dispose` when setting an existing key to a new value */\n  noDisposeOnSet?: boolean\n}\n\nexport type SetOptions<K, V> = Pick<\n  TTLCacheOptions<K, V>,\n  'ttl' | 'noUpdateTTL' | 'noDisposeOnSet'\n>\nexport type GetOptions<K, V> = Pick<\n  TTLCacheOptions<K, V>,\n  'updateAgeOnGet' | 'ttl' | 'checkAgeOnGet'\n>\n\nexport type HasOptions<K, V> = Pick<\n  TTLCacheOptions<K, V>,\n  'updateAgeOnHas' | 'ttl' | 'checkAgeOnHas'\n>\n\nexport class TTLCache<K = unknown, V = unknown> {\n  expirations: Record<number, K[]> = Object.create(null)\n  data = new Map<K, V>()\n  expirationMap = new Map<K, number>()\n  ttl?: number\n  max: number\n  updateAgeOnGet: boolean\n  updateAgeOnHas: boolean\n  noUpdateTTL: boolean\n  noDisposeOnSet: boolean\n  checkAgeOnGet: boolean\n  checkAgeOnHas: boolean\n  dispose: DisposeFunction<K, V>\n  timer?: ReturnType<typeof setTimeout>\n  timerExpiration?: number\n  immortalKeys = new Set<K>()\n\n  constructor({\n    max = Infinity,\n    ttl,\n    updateAgeOnGet = false,\n    checkAgeOnGet = false,\n    updateAgeOnHas = false,\n    checkAgeOnHas = false,\n    noUpdateTTL = false,\n    dispose,\n    noDisposeOnSet = false,\n  }: TTLCacheOptions<K, V> = {}) {\n    if (ttl !== undefined && !isPosIntOrInf(ttl)) {\n      throw new TypeError(\n        'ttl must be positive integer or Infinity if set',\n      )\n    }\n    if (!isPosIntOrInf(max)) {\n      throw new TypeError('max must be positive integer or Infinity')\n    }\n    this.ttl = ttl\n    this.max = max\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.checkAgeOnGet = !!checkAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.checkAgeOnHas = !!checkAgeOnHas\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDisposeOnSet = !!noDisposeOnSet\n    if (dispose !== undefined) {\n      if (typeof dispose !== 'function') {\n        throw new TypeError('dispose must be function if set')\n      }\n      this.dispose = dispose\n    } else {\n      this.dispose = (_, __, ___) => {}\n    }\n\n    this.timer = undefined\n    this.timerExpiration = undefined\n  }\n\n  setTimer(expiration: number, ttl: number) {\n    if (this.timerExpiration && this.timerExpiration < expiration) {\n      return\n    }\n\n    if (this.timer) {\n      clearTimeout(this.timer)\n    }\n\n    const t = setTimeout(\n      () => {\n        this.timer = undefined\n        this.timerExpiration = undefined\n        this.purgeStale()\n        for (const exp in this.expirations) {\n          const e = Number(exp)\n          this.setTimer(e, e - now())\n          break\n        }\n      },\n      Math.max(0, ttl),\n    )\n\n    /* c8 ignore start - affordance for non-node envs */\n    if (t.unref) t.unref()\n    /* c8 ignore stop */\n\n    this.timerExpiration = expiration\n    this.timer = t\n  }\n\n  // hang onto the timer so we can clearTimeout if all items\n  // are deleted.  Deno doesn't have Timer.unref(), so it\n  // hangs otherwise.\n  cancelTimer() {\n    if (this.timer) {\n      clearTimeout(this.timer)\n      this.timerExpiration = undefined\n      this.timer = undefined\n    }\n  }\n\n  /* c8 ignore start */\n  cancelTimers() {\n    process.emitWarning(\n      'TTLCache.cancelTimers has been renamed to ' +\n        'TTLCache.cancelTimer (no \"s\"), and will be removed in the next ' +\n        'major version update',\n    )\n    return this.cancelTimer()\n  }\n  /* c8 ignore stop */\n\n  clear() {\n    const entries =\n      this.dispose !== TTLCache.prototype.dispose ? [...this] : []\n    this.data.clear()\n    this.expirationMap.clear()\n    // no need for any purging now\n    this.cancelTimer()\n    this.expirations = Object.create(null)\n    for (const [key, val] of entries as [K, V][]) {\n      this.dispose(val, key, 'delete')\n    }\n  }\n\n  setTTL(key: K, ttl = this.ttl) {\n    const current = this.expirationMap.get(key)\n    if (current !== undefined) {\n      // remove from the expirations list, so it isn't purged\n      const exp = this.expirations[current]\n      if (!exp || exp.length <= 1) {\n        delete this.expirations[current]\n      } else {\n        this.expirations[current] = exp.filter(k => k !== key)\n      }\n    }\n\n    if (ttl && ttl !== Infinity) {\n      this.immortalKeys.delete(key)\n      const expiration = Math.floor(now() + ttl)\n      this.expirationMap.set(key, expiration)\n      if (!this.expirations[expiration]) {\n        this.expirations[expiration] = []\n        this.setTimer(expiration, ttl)\n      }\n      this.expirations[expiration].push(key)\n    } else {\n      this.immortalKeys.add(key)\n      this.expirationMap.set(key, Infinity)\n    }\n  }\n\n  set(\n    key: K,\n    val: V,\n    {\n      ttl = this.ttl,\n      noUpdateTTL = this.noUpdateTTL,\n      noDisposeOnSet = this.noDisposeOnSet,\n    }: SetOptions<K, V> = {},\n  ) {\n    if (!isPosIntOrInf(ttl)) {\n      throw new TypeError('ttl must be positive integer or Infinity')\n    }\n    if (this.expirationMap.has(key)) {\n      if (!noUpdateTTL) {\n        this.setTTL(key, ttl)\n      }\n      // has old value\n      const oldValue = this.data.get(key)\n      const disp = !noDisposeOnSet && this.data.has(key)\n      if (oldValue !== val) {\n        this.data.set(key, val)\n        if (disp) {\n          this.dispose(oldValue as V, key, 'set')\n        }\n      }\n    } else {\n      this.setTTL(key, ttl)\n      this.data.set(key, val)\n    }\n\n    while (this.size > this.max) {\n      this.purgeToCapacity()\n    }\n\n    return this\n  }\n\n  has(\n    key: K,\n    {\n      checkAgeOnHas = this.checkAgeOnHas,\n      ttl = this.ttl,\n      updateAgeOnHas = this.updateAgeOnHas,\n    }: HasOptions<K, V> = {},\n  ) {\n    if (this.data.has(key)) {\n      if (checkAgeOnHas && this.getRemainingTTL(key) === 0) {\n        this.delete(key)\n        return false\n      }\n      if (updateAgeOnHas) {\n        this.setTTL(key, ttl)\n      }\n      return true\n    }\n    return false\n  }\n\n  getRemainingTTL(key: K) {\n    const expiration = this.expirationMap.get(key)\n    return expiration === Infinity\n      ? expiration\n      : expiration !== undefined\n        ? Math.max(0, Math.ceil(expiration - now()))\n        : 0\n  }\n\n  get(\n    key: K,\n    {\n      updateAgeOnGet = this.updateAgeOnGet,\n      ttl = this.ttl,\n      checkAgeOnGet = this.checkAgeOnGet,\n    }: GetOptions<K, V> = {},\n  ) {\n    const val = this.data.get(key)\n    if (checkAgeOnGet && this.getRemainingTTL(key) === 0) {\n      this.delete(key)\n      return undefined\n    }\n    if (updateAgeOnGet) {\n      this.setTTL(key, ttl)\n    }\n    return val\n  }\n\n  delete(key: K) {\n    const current = this.expirationMap.get(key)\n    if (current !== undefined) {\n      const value = this.data.get(key) as V\n      this.data.delete(key)\n      this.expirationMap.delete(key)\n      this.immortalKeys.delete(key)\n      const exp = this.expirations[current]\n      if (exp) {\n        if (exp.length <= 1) {\n          delete this.expirations[current]\n        } else {\n          this.expirations[current] = exp.filter(k => k !== key)\n        }\n      }\n      this.dispose(value, key, 'delete')\n      if (this.size === 0) {\n        this.cancelTimer()\n      }\n      return true\n    }\n    return false\n  }\n\n  purgeToCapacity() {\n    for (const exp in this.expirations) {\n      const keys = this.expirations[exp] as K[]\n      if (this.size - keys.length >= this.max) {\n        delete this.expirations[exp]\n        const entries: [K, V][] = []\n        for (const key of keys) {\n          entries.push([key, this.data.get(key) as V])\n          this.data.delete(key)\n          this.expirationMap.delete(key)\n        }\n        for (const [key, val] of entries) {\n          this.dispose(val, key, 'evict')\n        }\n      } else {\n        const s = this.size - this.max\n        const entries: [K, V][] = []\n        for (const key of keys.splice(0, s)) {\n          entries.push([key, this.data.get(key) as V])\n          this.data.delete(key)\n          this.expirationMap.delete(key)\n        }\n        for (const [key, val] of entries) {\n          this.dispose(val, key, 'evict')\n        }\n        return\n      }\n    }\n  }\n\n  get size() {\n    return this.data.size\n  }\n\n  purgeStale() {\n    const n = Math.ceil(now())\n    for (const exp in this.expirations) {\n      if (exp === 'Infinity' || Number(exp) > n) {\n        return\n      }\n\n      /* c8 ignore start\n       * mysterious need for a guard here?\n       * https://github.com/isaacs/ttlcache/issues/26 */\n      const keys = [...(this.expirations[exp] || [])]\n      /* c8 ignore stop */\n      const entries: [K, V][] = []\n      delete this.expirations[exp]\n      for (const key of keys) {\n        entries.push([key, this.data.get(key) as V])\n        this.data.delete(key)\n        this.expirationMap.delete(key)\n      }\n      for (const [key, val] of entries) {\n        this.dispose(val, key, 'stale')\n      }\n    }\n    if (this.size === 0) {\n      this.cancelTimer()\n    }\n  }\n\n  *entries() {\n    for (const exp in this.expirations) {\n      for (const key of this.expirations[exp] as K[]) {\n        yield [key, this.data.get(key)] as [K, V]\n      }\n    }\n    for (const key of this.immortalKeys) {\n      yield [key, this.data.get(key)] as [K, V]\n    }\n  }\n  *keys() {\n    for (const exp in this.expirations) {\n      for (const key of this.expirations[exp] as K[]) {\n        yield key\n      }\n    }\n    for (const key of this.immortalKeys) {\n      yield key\n    }\n  }\n  *values() {\n    for (const exp in this.expirations) {\n      for (const key of this.expirations[exp] as K[]) {\n        yield this.data.get(key) as V\n      }\n    }\n    for (const key of this.immortalKeys) {\n      yield this.data.get(key) as V\n    }\n  }\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n}\n"]}