import { createExposureEvent, LRUInMemoryAssignmentCache, } from '@datadog/flagging-core';
import { OpenFeatureEventEmitter, ProviderEvents } from '@openfeature/server-sdk';
import { evaluate } from './configuration/evaluation';
import { InitializationController } from './initialization-controller';
/**
 * Default timeout in milliseconds for provider initialization.
 */
const DEFAULT_INITIALIZATION_TIMEOUT_MS = 30000;
export class DatadogNodeServerProvider {
    constructor(options) {
        this.options = options;
        this.metadata = {
            name: 'datadog-node-server',
        };
        this.runsOn = 'server';
        this.hooks = [];
        this.events = new OpenFeatureEventEmitter();
        this.exposureCache = new LRUInMemoryAssignmentCache(50000);
    }
    /**
     * Used by dd-source-js
     */
    getConfiguration() {
        return this.configuration;
    }
    /**
     * Used by dd-source-js
     */
    setConfiguration(configuration) {
        var _a, _b, _c;
        const prevCreatedAt = (_a = this.configuration) === null || _a === void 0 ? void 0 : _a.createdAt;
        const hadConfiguration = !!this.configuration;
        if (hadConfiguration && this.configuration !== configuration) {
            this.events.emit(ProviderEvents.ConfigurationChanged);
            const newCreatedAt = configuration === null || configuration === void 0 ? void 0 : configuration.createdAt;
            if (prevCreatedAt !== newCreatedAt) {
                (_b = this.exposureCache) === null || _b === void 0 ? void 0 : _b.clear();
            }
            this.configuration = configuration;
            return;
        }
        this.configuration = configuration;
        if ((_c = this.initController) === null || _c === void 0 ? void 0 : _c.isInitializing()) {
            // First configuration during initialization - resolve the initialization promise
            // This will cause OpenFeature SDK to emit PROVIDER_READY
            this.initController.complete();
        }
        else if (!hadConfiguration) {
            // Configuration is being set after initialization completed/failed (e.g., after timeout)
            // Emit PROVIDER_READY to signal recovery from error state
            this.events.emit(ProviderEvents.Ready);
        }
    }
    /**
     * Used by dd-source-js
     */
    setError(error) {
        var _a;
        if ((_a = this.initController) === null || _a === void 0 ? void 0 : _a.isInitializing()) {
            this.initController.fail(error);
        }
        else {
            this.events.emit(ProviderEvents.Error, { error });
        }
    }
    /**
     * Used by the OpenFeature SDK to set the status based on initialization.
     * Status of 'PROVIDER_READY' is emitted with a resolved promise.
     * Status of 'PROVIDER_ERROR' is emitted with a rejected promise.
     *
     * Since we aren't loading the configuration in this Provider, we will simulate
     * loading functionality via InitializationController.
     * See setConfiguration and setError for more details.
     */
    async initialize() {
        var _a, _b;
        if (this.configuration) {
            return;
        }
        const timeoutMs = (_a = this.options.initializationTimeoutMs) !== null && _a !== void 0 ? _a : DEFAULT_INITIALIZATION_TIMEOUT_MS;
        this.initController = new InitializationController(timeoutMs, () => this.setError(new Error(`Initialization timeout after ${timeoutMs}ms`)));
        await this.initController.wait();
        await ((_b = this.exposureCache) === null || _b === void 0 ? void 0 : _b.init());
    }
    async resolveBooleanEvaluation(flagKey, defaultValue, context, _logger) {
        const resolutionDetails = evaluate(this.configuration, 'boolean', flagKey, defaultValue, context, _logger);
        this.handleExposure(flagKey, context, resolutionDetails);
        return resolutionDetails;
    }
    async resolveStringEvaluation(flagKey, defaultValue, context, _logger) {
        const resolutionDetails = evaluate(this.configuration, 'string', flagKey, defaultValue, context, _logger);
        this.handleExposure(flagKey, context, resolutionDetails);
        return resolutionDetails;
    }
    async resolveNumberEvaluation(flagKey, defaultValue, context, _logger) {
        const resolutionDetails = evaluate(this.configuration, 'number', flagKey, defaultValue, context, _logger);
        this.handleExposure(flagKey, context, resolutionDetails);
        return resolutionDetails;
    }
    async resolveObjectEvaluation(flagKey, defaultValue, context, _logger) {
        // type safety: OpenFeature interface requires us to return a
        // specific T for *any* value of T (which could be any subtype of
        // JsonValue). We can't even theoretically implement it in a
        // type-sound way because there's no runtime information passed to
        // learn what type the user expects. So it's up to the user to
        // make sure they pass the appropriate type.
        const resolutionDetails = evaluate(this.configuration, 'object', flagKey, defaultValue, context, _logger);
        this.handleExposure(flagKey, context, resolutionDetails);
        return resolutionDetails;
    }
    handleExposure(flagKey, context, resolutionDetails) {
        var _a, _b, _c;
        const timestamp = Date.now();
        const evalutationDetails = {
            ...resolutionDetails,
            flagKey: flagKey,
            flagMetadata: (_a = resolutionDetails.flagMetadata) !== null && _a !== void 0 ? _a : {},
        };
        const exposureEvent = createExposureEvent(context, evalutationDetails);
        if (!exposureEvent) {
            return;
        }
        const hasLoggedAssignment = (_b = this.exposureCache) === null || _b === void 0 ? void 0 : _b.has(exposureEvent);
        if (hasLoggedAssignment) {
            return;
        }
        if (this.options.exposureChannel.hasSubscribers) {
            this.options.exposureChannel.publish({ ...exposureEvent, timestamp });
            (_c = this.exposureCache) === null || _c === void 0 ? void 0 : _c.set(exposureEvent);
        }
    }
}
//# sourceMappingURL=provider.js.map